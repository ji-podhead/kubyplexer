/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export class ExternalObject<T> {
  readonly '': {
    readonly '': unique symbol
    [K: symbol]: T
  }
}
/** This enum describes the level or severity of a diagnostic message produced by the compiler. */
export const enum DiagnosticLevel {
  /** The diagnostic found is an error that prevents successful compilation. */
  Error = 0,
  /** The diagnostic found is a warning. */
  Warning = 1
}
/**
 * This structure represent a diagnostic emitted while compiling .slint code.
 *
 * It is basically a message, a level (warning or error), attached to a
 * position in the code.
 */
export interface Diagnostic {
  /** The level for this diagnostic. */
  level: DiagnosticLevel
  /** Message for this diagnostic. */
  message: string
  /** The line number in the .slint source file. The line number starts with 1. */
  lineNumber: number
  columnNumber: number
  /** The path of the source file where this diagnostic occurred. */
  fileName?: string
}
export const enum ValueType {
  Void = 0,
  Number = 1,
  String = 2,
  Bool = 3,
  Model = 4,
  Struct = 5,
  Brush = 6,
  Image = 7
}
/** RgbaColor represents a color in the Slint run-time, represented using 8-bit channels for red, green, blue and the alpha (opacity). */
export interface RgbaColor {
  /** Represents the red channel of the color as u8 in the range 0..255. */
  red: number
  /** Represents the green channel of the color as u8 in the range 0..255. */
  green: number
  /** Represents the blue channel of the color as u8 in the range 0..255. */
  blue: number
  /** Represents the alpha channel of the color as u8 in the range 0..255. */
  alpha?: number
}
/**
 * A brush is a data structure that is used to describe how
 * a shape, such as a rectangle, path or even text, shall be filled.
 * A brush can also be applied to the outline of a shape, that means
 * the fill of the outline itself.
 */
export interface Brush {
  /**
   * Defines a solid color brush from rgba.
   *
   * If no color is set it defaults to transparent.
   */
  color?: RgbaColor
}
export function mockElapsedTime(ms: number): void
export function getMockedTime(): number
export const enum ProcessEventsResult {
  Continue = 0,
  Exited = 1
}
export function processEvents(): ProcessEventsResult
export function invokeFromEventLoop(callback: (...args: any[]) => any): void
export function setQuitOnLastWindowClosed(quitOnLastWindowClosed: boolean): void
export type JsComponentCompiler = ComponentCompiler
/**
 * ComponentCompiler is the entry point to the Slint interpreter that can be used
 * to load .slint files or compile them on-the-fly from a string.
 */
export class ComponentCompiler {
  /** Returns a new ComponentCompiler. */
  constructor()
  set includePaths(includePaths: Array<string>)
  get includePaths(): Array<string>
  set libraryPaths(paths: Record<string, string>)
  get libraryPaths(): Record<string, string>
  set style(style: string)
  get style(): string | null
  get diagnostics(): Array<Diagnostic>
  /**
   * Compile a .slint file into a ComponentDefinition
   *
   * Returns the compiled `ComponentDefinition` if there were no errors.
   */
  buildFromPath(path: string): JsComponentDefinition | null
  /** Compile some .slint code into a ComponentDefinition */
  buildFromSource(sourceCode: string, path: string): JsComponentDefinition | null
}
export type JsComponentDefinition = ComponentDefinition
export class ComponentDefinition {
  constructor()
  get properties(): Array<JsProperty>
  get callbacks(): Array<string>
  get globals(): Array<string>
  globalProperties(globalName: string): Array<JsProperty> | null
  globalCallbacks(globalName: string): Array<string> | null
  create(): JsComponentInstance | null
  get name(): string
}
export type JsComponentInstance = ComponentInstance
export class ComponentInstance {
  constructor()
  definition(): ComponentDefinition
  getProperty(name: string): unknown
  setProperty(propName: string, jsValue: unknown): void
  getGlobalProperty(globalName: string, name: string): unknown
  setGlobalProperty(globalName: string, propName: string, jsValue: unknown): void
  setCallback(callbackName: string, callback: (...args: any[]) => any): void
  setGlobalCallback(globalName: string, callbackName: string, callback: (...args: any[]) => any): void
  invoke(callbackName: string, arguments: Array<unknown>): unknown
  invokeGlobal(globalName: string, callbackName: string, arguments: Array<unknown>): unknown
  sendMouseClick(x: number, y: number): void
  sendKeyboardStringSequence(sequence: string): void
  window(): JsWindow
}
export type JsProperty = Property
export class Property {
  name: string
  valueType: ValueType
}
export type JsWindow = Window
/**
 * This type represents a window towards the windowing system, that's used to render the
 * scene of a component. It provides API to control windowing system specific aspects such
 * as the position on the screen.
 */
export class Window {
  /** @hidden */
  constructor()
  /**
   * Shows the window on the screen. An additional strong reference on the
   * associated component is maintained while the window is visible.
   */
  show(): void
  /** Hides the window, so that it is not visible anymore. */
  hide(): void
  /**
   * Returns the visibility state of the window. This function can return false even if you previously called show()
   * on it, for example if the user minimized the window.
   */
  get visible(): boolean
  /** Returns the logical position of the window on the screen. */
  get logicalPosition(): SlintPoint
  /** Sets the logical position of the window on the screen. */
  set logicalPosition(position: SlintPoint)
  /** Returns the physical position of the window on the screen. */
  get physicalPosition(): SlintPoint
  /** Sets the physical position of the window on the screen. */
  set physicalPosition(position: SlintPoint)
  /** Returns the logical size of the window on the screen, */
  get logicalSize(): SlintSize
  /** Sets the logical size of the window on the screen, */
  set logicalSize(size: SlintSize)
  /** Returns the physical size of the window on the screen, */
  get physicalSize(): SlintSize
  /** Sets the logical size of the window on the screen, */
  set physicalSize(size: SlintSize)
  /** Issues a request to the windowing system to re-render the contents of the window. */
  requestRedraw(): void
  /** Set or unset the window to display fullscreen. */
  set fullscreen(enable: boolean)
}
/** SlintRgbaColor implements {@link RgbaColor}. */
export class SlintRgbaColor {
  /** Creates a new transparent color. */
  constructor()
  /**
   * Construct a color from the red, green and blue color channel parameters. The alpha
   * channel will have the value 255.
   */
  static fromRgb(red: number, green: number, blue: number): SlintRgbaColor
  /** Construct a color from the alpha, red, green and blue color channel parameters. */
  static fromArgb(alpha: number, red: number, green: number, blue: number): SlintRgbaColor
  /** Returns the red channel of the color as number in the range 0..255. */
  get red(): number
  /** Returns the green channel of the color as number in the range 0..255. */
  get green(): number
  /** Returns the blue channel of the color as number in the range 0..255. */
  get blue(): number
  /** Returns the alpha channel of the color as number in the range 0..255. */
  get alpha(): number
  /**
   * by the specified factor. This is done by converting the color to the HSV
   * color space and multiplying the brightness (value) with (1 + factor).
   * The result is converted back to RGB and the alpha channel is unchanged.
   * So for example `brighter(0.2)` will increase the brightness by 20%, and
   * calling `brighter(-0.5)` will return a color that's 50% darker.
   */
  brighter(factor: number): SlintRgbaColor
  /**
   * Returns a new version of this color that has the brightness decreased
   * by the specified factor. This is done by converting the color to the HSV
   * color space and dividing the brightness (value) by (1 + factor). The
   * result is converted back to RGB and the alpha channel is unchanged.
   * So for example `darker(0.3)` will decrease the brightness by 30%.
   */
  darker(factor: number): SlintRgbaColor
  /**
   * Returns a new version of this color with the opacity decreased by `factor`.
   *
   * The transparency is obtained by multiplying the alpha channel by `(1 - factor)`.
   */
  transparentize(amount: number): SlintRgbaColor
  /**
   * Returns a new color that is a mix of `self` and `other`, with a proportion
   * factor given by `factor` (which will be clamped to be between `0.0` and `1.0`).
   */
  mix(other: SlintRgbaColor, factor: number): SlintRgbaColor
  /** Returns a new version of this color with the opacity set to `alpha`. */
  withAlpha(alpha: number): SlintRgbaColor
  /** Returns the color as string in hex representation e.g. `#000000` for black. */
  toString(): string
}
/** SlintBrush implements {@link Brush}. */
export class SlintBrush {
  constructor(color: RgbaColor)
  static fromBrush(brush: Brush): SlintBrush
  get color(): RgbaColor
  /** @hidden */
  get slintColor(): SlintRgbaColor
  /** Returns true if this brush contains a fully transparent color (alpha value is zero) */
  get isTransparent(): boolean
  /** Returns true if this brush is fully opaque. */
  get isOpaque(): boolean
  /**
   * Returns a new version of this brush that has the brightness increased
   * by the specified factor. This is done by calling [`Color::brighter`] on
   * all the colors of this brush.
   */
  brighter(factor: number): SlintBrush
  /**
   * Returns a new version of this brush that has the brightness decreased
   * by the specified factor. This is done by calling [`Color::darker`] on
   * all the color of this brush.
   */
  darker(factor: number): SlintBrush
  /**
   * Returns a new version of this brush with the opacity decreased by `factor`.
   *
   * The transparency is obtained by multiplying the alpha channel by `(1 - factor)`.
   */
  transparentize(amount: number): SlintBrush
  /**
   * Returns a new version of this brush with the related color's opacities
   * set to `alpha`.
   */
  withAlpha(alpha: number): SlintBrush
  /** @hidden */
  get brush(): ExternalObject<Brush>
  /**
   * Returns the color as string in hex representation e.g. `#000000` for black.
   * It is only implemented for solid color brushes.
   */
  toString(): string
}
/** SlintPoint implements {@link ImageData}. */
export class SlintImageData {
  /**
   * Constructs a new image with the given width and height.
   * Each pixel will set to red = 0, green = 0, blue = 0 and alpha = 0.
   */
  constructor(width: number, height: number)
  /** Returns the width of the image in pixels. */
  get width(): number
  /** Returns the height of the image in pixels. */
  get height(): number
  /**
   * Returns the image as buffer.
   * A Buffer is a subclass of Uint8Array.
   */
  get data(): Buffer
  get path(): unknown
  /** @hidden */
  get image(): ExternalObject<ImageData>
}
export type JsSlintModelNotify = SlintModelNotify
export class SlintModelNotify {
  constructor()
  rowDataChanged(row: number): void
  rowAdded(row: number, count: number): void
  rowRemoved(row: number, count: number): void
  reset(): void
}
/** SlintPoint implements {@link Point}. */
export class SlintPoint {
  x: number
  y: number
  /** Constructs new point from x and y. */
  constructor(x: number, y: number)
}
/** SlintPoint implements {@link Size}. */
export class SlintSize {
  width: number
  height: number
  /** Constructs a size from the given width and height. */
  constructor(width: number, height: number)
}
